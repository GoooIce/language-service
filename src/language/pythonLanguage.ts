import { StringOrRegExp } from '@cucumber/cucumber-expressions'
import { RegExps } from '@cucumber/cucumber-expressions/dist/cjs/src/ParameterType'

import { childrenToString, filter, NO_QUOTES } from './helpers.js'
import { Language, NodePredicate, TreeSitterSyntaxNode } from './types.js'

export const pythonLanguage: Language = {
  toParameterTypeName(node: TreeSitterSyntaxNode) {
    return node.text.slice(1, -1)
  },
  toParameterTypeRegExps(node: TreeSitterSyntaxNode) {
    const expr = node.text.slice(1, -1)
    const specialChars = '/[^$<>]/'
    const startsWithReg = specialChars
      .split('')
      .map(function (special_char: string) {
        return expr.startsWith(special_char)
      })
      .includes(true)
    if (startsWithReg) {
      return new RegExp(expr.slice(1, -1))
    } else {
      return new RegExp(expr.slice(1, -1))
    }
  },
  toStepDefinitionExpression(node: TreeSitterSyntaxNode): StringOrRegExp {
    // this removes the head and tail apostrophes
    const clean_word = node.text.slice(1, -1)
    // remove python named capture groups.
    // TODO: This should be temporary. Python supports
    // a wider array of regex features than javascript
    // a singular way of communicating regex consistent
    // across languages is necessary
    const specialChars = '/[^$<>]/'
    const isRegex = specialChars
      .split('')
      .map(function (special_char: string) {
        return clean_word.startsWith(special_char)
      })
      .includes(true)
    if (isRegex) {
      const replaced = clean_word.slice(1, -1)
      return new RegExp(replaced)
    } else {
      // then it's an expression
      return clean_word
    }
  },
  defineParameterTypeQueries: [
    `(call
 arguments: (argument_list
    (keyword_argument
       name: (identifier) @name-key
       value: (string) @name
       (#eq? @name-key "name")
    )?
    (keyword_argument
       name: (identifier) @regexp-key
       value: (string) @expression
       (#eq? @regexp-key "regexp")
    )?
 )
)@root`,
  ],
  defineStepDefinitionQueries: [
    `
(decorated_definition
    (decorator
        (call
            function: (identifier) @method
            arguments: (argument_list (string) @expression)
        )
    )
    (#match? @method "(given|when|then)")
) @root
`,
  ],
  snippetParameters: {
    int: { type: 'int' },
    float: { type: 'float' },
    word: { type: 'str' },
    string: { type: 'str' },
    double: { type: 'double' },
    bigdecimal: { type: 'decimal' },
    byte: { type: 'byte' },
    short: { type: 'short' },
    long: { type: 'long' },
    biginteger: { type: 'int' },
    '': { type: 'Object', name: 'arg' },
  },
  defaultSnippetTemplate: `
  @{{ #lowercase }}{{ keyword }}{{ /lowercase }}('{{ expression }}')
  def step_{{ #lowercase }}{{ keyword }}{{ /lowercase }}(context, {{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}{{ /parameters }}) :
      # This was autogenerated using cucumber syntax.
      # Please convert to use regular expressions, as Behave does not currently support Cucumber Expressions`,
}
